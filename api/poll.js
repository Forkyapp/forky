const axios = require('axios');

// ============================================
// CONFIGURATION
// ============================================

const CLICKUP_API_KEY = process.env.CLICKUP_API_KEY;
const CLICKUP_BOT_USER_ID = parseInt(process.env.CLICKUP_BOT_USER_ID || '0');
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_OWNER = process.env.GITHUB_OWNER;
const GITHUB_REPO = process.env.GITHUB_REPO;
const GITHUB_BASE_BRANCH = process.env.GITHUB_BASE_BRANCH || 'main';

// GitHub API helper
const github = axios.create({
  baseURL: 'https://api.github.com',
  headers: {
    'Authorization': `token ${GITHUB_TOKEN}`,
    'Accept': 'application/vnd.github.v3+json',
    'User-Agent': 'ClickUp-Claude-GitHub-Bot'
  }
});

// Note: processedTasks resets on each invocation (serverless)
// We rely on checking if GitHub branch exists to avoid duplicates
const processedTasks = new Set();

// ============================================
// HELPER FUNCTIONS
// ============================================

async function updateTaskStatus(taskId, statusId) {
  try {
    await axios.put(
      `https://api.clickup.com/api/v2/task/${taskId}`,
      { status: statusId },
      {
        headers: {
          'Authorization': CLICKUP_API_KEY,
          'Content-Type': 'application/json'
        }
      }
    );
    console.log(`Updated task ${taskId} status to ${statusId}`);
  } catch (error) {
    console.error(`Error updating task status:`, error.message);
  }
}

async function getAssignedTasks() {
  try {
    const response = await axios.get(
      `https://api.clickup.com/api/v2/space/${CLICKUP_SPACE_ID}/task`,
      {
        headers: {
          'Authorization': CLICKUP_API_KEY,
          'Content-Type': 'application/json'
        },
        params: {
          assignees: [CLICKUP_BOT_USER_ID],
          subtasks: false,
          order_by: 'updated',
          reverse: true
        }
      }
    );

    return response.data.tasks || [];
  } catch (error) {
    console.error('Error fetching tasks:', error.message);
    return [];
  }
}

async function processTask(task, isUpdate = false) {
  const taskId = task.id;
  const taskTitle = task.name;
  const taskDescription = task.description || task.text_content || '';
  const taskStatus = task.status?.status;

  console.log(`Processing task ${taskId}: ${taskTitle} (status: ${taskStatus})`);

  // Mock Claude API - generate hardcoded file
  const generatedCode = `// Generated from ClickUp Task: ${taskTitle}
// Task ID: ${taskId}
// Description: ${taskDescription}

console.log("Hello World");

// This is a mocked file.
// TODO: Integrate Claude API to generate actual code based on the task.
`;

  const branchName = `task-${taskId}`;
  const fileName = 'generated-code.js';
  const commitMessage = `Add generated code for ClickUp task: ${taskTitle}`;
  const prTitle = `[ClickUp #${taskId}] ${taskTitle}`;
  const prBody = `## ClickUp Task

**Task ID:** ${taskId}
**Title:** ${taskTitle}
**Description:**
${taskDescription || 'No description provided'}

---

This PR was automatically generated by the ClickUp-Claude-GitHub integration.

Generated file: \`${fileName}\`
`;

  try {
    // Check if branch already exists
    let branchExists = false;
    let existingPR = null;

    try {
      await github.get(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/git/ref/heads/${branchName}`);
      branchExists = true;

      // Check if there's an existing PR
      const prsResponse = await github.get(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/pulls?head=${GITHUB_OWNER}:${branchName}&state=open`);
      if (prsResponse.data.length > 0) {
        existingPR = prsResponse.data[0];
      }

    } catch (err) {
      if (err.response?.status !== 404) {
        throw err;
      }
    }

    // If task is "in process" and PR exists, update it
    if (branchExists && existingPR && taskStatus === 'in process') {
      console.log(`Updating existing PR #${existingPR.number} for task ${taskId}`);

      // Update the file
      const existingFile = await github.get(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${fileName}?ref=${branchName}`);
      const contentEncoded = Buffer.from(generatedCode).toString('base64');

      await github.put(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${fileName}`, {
        message: `Update generated code for ClickUp task: ${taskTitle}`,
        content: contentEncoded,
        branch: branchName,
        sha: existingFile.data.sha
      });

      console.log(`Updated PR #${existingPR.number}`);
      return { updated: true, prUrl: existingPR.html_url };
    }

    // If branch exists but task not "in process", skip
    if (branchExists) {
      console.log(`Branch ${branchName} already exists, skipping...`);
      return { skipped: true, branch: branchName };
    }

    // Get base branch reference
    const refResponse = await github.get(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/git/ref/heads/${GITHUB_BASE_BRANCH}`);
    const baseSha = refResponse.data.object.sha;
    console.log(`Base branch SHA: ${baseSha}`);

    // Create new branch
    await github.post(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/git/refs`, {
      ref: `refs/heads/${branchName}`,
      sha: baseSha
    });
    console.log(`Created branch: ${branchName}`);

    // Create/update file
    const contentEncoded = Buffer.from(generatedCode).toString('base64');
    await github.put(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${fileName}`, {
      message: commitMessage,
      content: contentEncoded,
      branch: branchName
    });
    console.log(`Committed file: ${fileName}`);

    // Create Pull Request
    const prResponse = await github.post(`/repos/${GITHUB_OWNER}/${GITHUB_REPO}/pulls`, {
      title: prTitle,
      head: branchName,
      base: GITHUB_BASE_BRANCH,
      body: prBody
    });
    console.log(`Pull Request created: ${prResponse.data.html_url}`);

    // Update ClickUp task status to "can be checked"
    // Find "can be checked" status ID from task statuses
    const canBeCheckedStatus = 'p90070039602_8Mqcg4pn'; // This is from your task data
    await updateTaskStatus(taskId, canBeCheckedStatus);

    return prResponse.data;

  } catch (error) {
    console.error('Error creating GitHub PR:', error.message);
    if (error.response) {
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
}

// ============================================
// CRON HANDLER
// ============================================

module.exports = async (req, res) => {
  try {
    console.log('Polling ClickUp for new tasks...');

    const tasks = await getAssignedTasks();
    console.log(`Found ${tasks.length} assigned tasks`);
    console.log(`Currently tracking ${processedTasks.size} processed tasks`);

    let processedCount = 0;
    const results = [];

    for (const task of tasks) {
      // Skip if already processed
      if (processedTasks.has(task.id)) {
        console.log(`Skipping already processed task: ${task.id}`);
        continue;
      }

      console.log(`Processing new task: ${task.id} - ${task.name}`);

      try {
        const result = await processTask(task);
        if (result) {
          processedTasks.add(task.id);

          if (result.skipped) {
            console.log(`Task ${task.id} already has a PR`);
          } else {
            processedCount++;
            results.push({
              taskId: task.id,
              prUrl: result.html_url
            });
          }
        }
      } catch (error) {
        console.error(`Failed to process task ${task.id}:`, error.message);
        results.push({
          taskId: task.id,
          error: error.message
        });
      }
    }

    // Clean up old processed tasks (keep only last 100)
    if (processedTasks.size > 100) {
      const taskArray = Array.from(processedTasks);
      processedTasks.clear();
      taskArray.slice(-100).forEach(id => processedTasks.add(id));
    }

    return res.status(200).json({
      success: true,
      message: `Polling complete. Processed ${processedCount} new tasks.`,
      results
    });

  } catch (error) {
    console.error('Error in polling function:', error);
    return res.status(500).json({
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
};
